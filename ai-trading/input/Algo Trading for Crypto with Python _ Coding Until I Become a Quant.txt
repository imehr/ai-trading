 you you you you you you you you you you you you But I had to do something before hopping on. Hope everyone's having a good day. Let me do the quick audio check. Sounds maybe a little bit quiet. I think it's fine. I think it's fine. Yeah, should be fine. Alright, let me mute myself and share screen. So today there are a couple things I want to do. One is I want to get the historical part of the cracked API working. Wait, do I have everything up? Can I do this? Let me open cursor, bring that over here. And we are, if I can find the button, good to go. So I want to do a couple of things today. I want to have, this should not be there. What I want to do is I want to implement a couple more of these features that we were working on yesterday. So we were working on looking at correlations. We ended up doing some different things, such as plotting, adding a function to look at the correlation of your data set at different lag times and see how that correlation decays. And sort of the slope of that decay, or if you were to get a non-linear decay rate, then these kind of tell you something about the long term correlation of the stock price. So that was something I worked on a little bit after getting off. But today primarily what I want to do is I want to implement this Q-sum filter. I guess they call it, I don't know why it's called a filter really. That's the first thing. So after that we'll take a look at how good this AI coding thing is at building out parts of the WebSocket API basically. Or it might be a REST API, I don't know exactly what the Kraken Historical API looks like, but we will have to figure that out. So if anyone else has anything you want to go over, talk about, just drop it in the chat and we can do that if it's like reasonably on topic. I mean, something finance related obviously. Not, yeah, not like, I don't even know what someone might suggest. Anything finance related we can do, or math related. If you have any cool ideas we can talk about those. Okay, so this Q-sum filter. And again, we're looking at the book advances in financial machine learning by the Prado for this. The Q-sum filter is a quality control method designed to detect a shift in the mean value of measured quantity away from a target value. Consider IID. This you can think of is it's like basically meaning you have some process which observations are independent of another and they are distributed in a normal fashion. It's basically what IID means. And then we have so some sequence of observations indexed by at time. A rising from a locally stationary process, a stationary process is simply one where the drift of the price is or the drift of whatever the function is mapping your input variables to that target variable is relatively stable over time. That's what a stationary process is. It's a bit different than if you're coming from like a physics background. This means a totally different thing. So we define the cumulative sums from zero to s of t minus one plus y. Also, it's going to be the max of the zero s of t minus one plus y minus e t minus one of y of t with the boundary condition at s is zero equals zero. So let's think about this. So what is s t? So we start with s of t is zero or I mean s of zero is zero. And then this recommends an action at the first time satisfying s of t is larger than h for some threshold h. Note that s of t equals zero whenever y of t minus or less than e of t minus one of y of t minus s t minus one. Have they told us what e of t is? Is that defined prior in the chapter here? Where's our e of t? Or sorry, e sub t. So this is just the expected value of y, I guess, for the last time step. So this zero floor means we will skip some downward deviations that otherwise would make s of t negative. The reason is the filter is set up to identify a sequence of upside divergences from any reset level zero. And in particular, the threshold is activated when s of t is greater than h, which implies that there's some tau between one and t. Such that the sum of y, i minus the expected value at i minus one of y of t is greater than this h threshold. The concept of run ups can be extended to include run downs and you would just obviously then flip the sign of, well not flip the sign but instead of a max here you would want to take a min. And you can see that here. So I'm not clear on what this e of t is. Have they discussed this prior in the chapter, possibly? I don't remember. It's been a while since I read chapter two here. Do we. Do we have e has to be the expected value of y. So we define cumulative sums. What is y then? Oh, these are our observations. So this is kind of like f of t. I'm going to write this in a way that's kind of more intuitive, I think, for me. So we have s of t is going to be max max of the zero and the previous s of t. Plus where are we? I was keeping an eye on dogecoin. I thought we might get down. I was targeting this kind of like 11 cent price level. Y of t minus expected value at I don't understand this. This is what I'm not understanding. So it's the max of this plus what plus Y of t. If anyone's used this filter and you know what the e t is, feel free to explain it in the chat. E t minus one or even if you just have an idea of what it is. E t minus one. Y of t. And that's pretty much the whole thing. So we start with some I'm going to write this as just f of t. And then this is kind of like an expected value of f of t is what I'm assuming, but I don't know what the t minus one means. And then this is just I'm going to write this as s of t minus one. So let's just implement this now. And what we'll do is sort of plug in the correct logic afterwards. So when we have our target column, this is going to be like our f of t, f of t equals df target column to numpy. And then we're going to run along this whole thing. So we'll say for. Let's see s of t is the max of zero and s of t minus one. So let's then do this. Let's say s of t is numpy zeros like f of t. And then what we do. There's probably some way to do this in Pantas, I guess, right? s of t minus one plus y of t. So minus this e of t. And this is also e of t minus one. Now how do we compute this e of t? Let's see if they say in the chapter. Let's keep reading a bit. This procedure would recommend an action satisfying at the first t satisfying s of t is greater than h for some threshold h. So this hits a one or this hits a non zero value. I should say anytime this expression here is greater than zero. So greater zero is greater than s of t minus one. I'll write it as functions kind of s of t minus one plus f of t plus I'm just going to write this as it's sort of implicitly. I think the expected value of this. But yeah, so anytime our. This is less than. And our negative is going to be greater than f of t plus e t minus one. And this should be s sorry. How do I select? There we go. Delete that. This should be s of t minus one. Now did I miss a sign? I thought we were subtracting this one. Yeah, this should be a minus. Okay. So anytime the difference between the prior s and the previous expected value is less than or is greater than the function. We have this. I guess. But again, I'm not seeing what this e of t is. So let's see. Yeah. So whenever y is less than or equal to apparently. Yeah, I guess that makes sense. But I don't really see where the equal comes from. So. Y of t. Yeah. And then so what they did is they just multiplied out the minus sign f of t. Grit them in. Oh, wait. I don't know. Yeah. S. E. T minus one minus s. T minus one. Yeah. And this should then become minus right. Minus or equal. That's why because say we have something like a, you know, say this is minus five greater than minus three. We multiply both of these by minus one. I mean, sorry. Less than minus five less than minus three. We multiply both of these by minus one. This becomes five. And so we need to flip the sign of this as well. So this is our sort of expression that signals the scenario where we will have a non zero value in the q sum filter. So we're still not sure what this is. Let's look up another example. Q sum filter. So they write it as max of S of n. So they shipped everything up one step. S of n minus this word. So what is W? I think W is. So is this our process of these were our weights. What is this WN? Likelihood function measures how well a statistical model explains observed data. Like calculating the probability of seeing that data under different parameter values of the model. And then we're going to look at the probability distribution of the random variable. Okay. In maximum likelihood expectations. Can we just get a formula for this? Let's see q sum. Oh, they have an explanation in ML fin lab. Nice. Introduction to filters. Some kind of a trigger. Okay. Here we go. The q sum filter is a quality control. So they're just quoting the book. Okay. We sample a bar. If only if S and if he is greater than some threshold at which point we reset it to zero. So they just don't have any sort of explanation. Let's see if we can find something here. It's not working. So I might need to. Let's try asking the thing. What is E of T in the q sum filter given by the equation ST equals max zero. S T minus one plus Y T minus E T minus one. Let's see if this thing can tell us. While it does that, I will keep looking. Oh, this loaded. Nice. Control F q sum. Stance for cumulative sum. A statistical quantity control. It can be applied. Expected value or reference level at time T. It serves as a baseline. How do we compute it though? Expected values typical predefined value or dynamically calculated like a moving average that represents what you anticipate what should be under normal conditions by comparing Y of T against ET. The q sum filter can identify when Y of T DB. It's significantly from expected expectations applying it in your code ET is used but not defined appropriately implemented. You need to define how it's done. So I guess we can have multiple ways of computing this. Let's call it ET mode equals simple moving average. We can compute it as a rolling thing. Let's do all this in pandas. E of T is going to be equal to, let's see, DF target column dot rolling window equals ET window. So we need this. The thought of the sort of convention in the code basis to have W via a window and we'll say what do we want? I don't know if the as a default or something. I should probably have a standard default wrote the code base. Min periods, I'm just going to do us one. No, no, no. Well, I don't know. Yeah, I'm going to do for now. We'll do min periods equals one. And then what do we need the mean and then let's cast it to an empire. Let's double check that this gives us no, not a numbers grant. Let's go ahead and do this. And let's use the testing notebook here because I already have some bars. Right. Let me check bars. No, okay. Apparently not. Let's load in some financial data. Now we have some financial data. And this financial data is just two month Bitcoin open high low clothes at five minute intervals. So now we have this. And let's say from dolphin dot labels dot indicators import Q some. Say something like this. Compute bars and let's see what we get here. Error target column is not defined. So, okay. Target column is not defined should be. Oh, I did underscore. Whoops. And I can do let's close out this file explorer. And then we can do something like this. Get the chat. The chat GPT thing out of the way that. Okay. So we have the function over here. I'm in the wrong file. So let's move this over to here. Q some will be this. And now this should run I think. Okay. So we get no, not a number set the beginning. That is good. And yeah. So now let's just go ahead and. Yeah, we're good here. Now let's roll through these because I think what we need to do at each time when we get a non zero s of t's we have to reset them. If I'm not mistaken. So let's see how this thing suggests to implement it. S of t. At time I is max of this expression. Yeah, that makes sense. And so I think. What we can do is we can simply do. S of t. Let's do a row. So I want to vectorize this so that we're not looping. And then we can do. Let's see. Max of zero. And then. This. Oh, no, we do need to loop. Yeah, we can't vectorize this. That's fine. So we take s of t. If I is equal to the max of this. And I think just this need to be a list, I think. So we take the max at the max of the prior s of t plus the function minus the expected value of the function. And then let's see what this looks like. And we'll do a. Yeah, this is fine. Bars dot head. Let's see our close Q sums. Do happen a bit. I'm going to drop the. Let's say mean let's add this as an option. Min periods equals 10. Or let's say, I don't know, 20. And then we'll do. Min periods equals. Min periods. And then what we should do at that point is if min periods greater than one. We need to slice all up the arrays. F of t will be from min periods on. And then same thing for B of t and s of t. And then when we want to put it back in the data frame, we need to pad this. So we're kind of creating a lot of arrays here for no reason. This one we can call s of t full. And then we'll say s of t equals s of t full like this. And then what we'll do at the end is say s. T full. And then from the slice from min periods to the end, we'll assign these s of t values. So this should give us some not a numbers in the beginning, which I want, because it looked like we had a bit of nonsense. I'll know that will just give us zeros in the beginning, I believe. Oh, we didn't pass them in periods. Oh, indexes out of range. Max s t minus one. All right, then this loop has to go from min periods up to length of f of t. Okay. Let's see what, let's print f of t or length of f of t, I should say. 14667. And let's see. 14647. And then we need to subtract out the min period. So, curve IDX equals i minus min periods. And this should start us at zero. Right, print curve IDX. Let's just make sure that this starts us at zero. Okay. Good. And then we can get rid of this and then change all of these indices to curve IDX. I didn't save this. 14667. 14647 does not exist. Wait, length of values does not match length of index. Buh, buh, buh, buh. Oh, this is when we go to put it back into the where are we? Here. Oh, we need to pass in the s of t full. So, that was the point of repatting the numpy array. So, this works now. And now we should get some not a numbers in the beginning. Or zero, so I guess. What I'm going to do is instead of starting it as zeroes, let's do numpy dot ones like. Like, and then I'm going to multiply by numpy dot not a number. And that will make it so we can just do drop in a to remove any sort of nands that we get here. And I'm going to change the moving average window to be a little bit lower just for visualization purposes. Let's say. What do we need here? Let's think about doing min periods equals five. So, let's do like three. So that when we do data frame head, we'll be able to see that it is doing what's expected. So the first three are not a number. And then we start getting numbers. So I'm going to go ahead and put this up to 20 again. It's tabbing this for you. This thing does not do well with the tabbing. Okay, whatever. We'll leave it as one line. And now, what do we want to do? How do we visualize this? First, I guess let's see what this distribution looks like. I guess we can do a. I don't like this being called. But, in my mind, I guess it's fine. Let's do. Plot that hiss bars close to some. Let's get rid of this annoying thing. Okay, these seem way too high. Do these not seem way too high? That just me. What are the... Well, let's see what the mean of this expected value is. This could be the problem. Print. Min. E of t. Not a number. Okay. Well, let's do it after we come in here, I suppose. Still not a number. Why? Print. Here seems to be our problem. I'm guessing. T. Oh, I should be doing E of t equals this. E of t equals this. How about now? There we go. And our mean is 60,000. So that's reasonable. We're dealing with Bitcoin data. So that seems like a reasonable average price. Now it's saying the bounds are out of range. So I guess when we slice the full things, we should be only going from... Yeah, maybe this is not the best way. Let's go from index to zero. To link the f of t minus mean periods. Now we don't need to do this per IDX thing anymore. So I was kind of mixing up whether or not we're slicing the arrays or keeping them the same like this when we start. And okay, what's the problem now? S of t, i. Maybe it should be minus one. Let's see if that does it. Could be off by one. No. Does this make sense? So when we print the length of f of t, right, we have this. Oh, we're never slicing f of t. Oh, I'm just typoing all over the place. How about now? There we go. A double typo, so we slice the of t twice and never slice f of t. So we're good here. I'm pretty sure. Now let's see if these are any more reasonable. Or it could just be that this is what it's supposed to look like. I'm just not super familiar with this filter. These numbers seem kind of crazy though, no? So if we think about it, let's think about. Let's plot s of t. See if it maybe it's climbing over time. Plot dot plot bars, close, cue some. Comment this out. So we do let's plot the close prices themselves as well on the same plot possibly. Okay. So let's see how someone else implements this. Because I'm not actually so sure what the, I mean, I get what you get out of the function. What you get out of the function is points of time. So any point of time where this is non zero is going to be a place where the difference between your, your function and the expected value of the function is larger than. And one, it's larger than it previously was and two, it's larger than some threshold is what you're going to do. So let's read maybe a little bit more. Okay. So they have it here. So he has the events. I hate this guy's like a notation is I'm just not a big fan. I mean, I guess you have to have the short name so if it's in the book, but. So time of events s, p o s, s and e g. I don't know what these are. Diff is going to be the raw difference. So presumably this is like s at t and s at t minus one. That's what I'm guessing these are going to be. For I and diff dot index. So from the first frame on. S pass s neg equals max of s positive. So he's doing these two separate things. So that's what s pause and s neg are going to be. If dot I look or dot look I. So it's the max of. I don't know. So s plus is this s minus is this. But where is he computing s plus and s neg. If s neg is less than or less than h, then you append the index. Okay. I understand. But where is his g raw? The function get the events receives two arguments. The raw time series we wish to filter and the threshold. One practical aspects that makes Q some filters appealing is that multiple events are not triggered by g raw hovering around a threshold level. Which is a floss offered by popular market signals like ballinger plans. It will require a full run of length h for g raw to trigger an event figure 2.3 illustrates. So let's do this. Let's see where our s of t is larger than some threshold. There's definitely something wrong though. Something is not right now. We're computing this. I'm pretty sure it's this. E of T. So the raw time series we wish to filter g raw. So what? What is g raw did so let's see what that does. If we have some. I'm just going to call it g raw will be equal to our bars close. G raw dot head. What? G raw dot head. G raw dot dip. Okay so it's just the change in price from the prior prices that literally all we're dealing with. Is that right? Let's also double check I suppose. G raw dot head. So we go down about $30. We go up about 20. We go down one. So we go down 30 up 20 down one. Okay so. Interesting. Let's simply take his code here. This code seems fine. And we can optimize later. So we don't need any of this rolling average nonsense apparently. But it seems like you would want a better approximation for the function. Then simply the function value at the previous time. So it seems a bit odd. But I also don't know why this is blowing up. So I'm going to leave this as is because I think there's some value in this once we figure out the bug. Death I'm just going to call it book use them. And then we'll do this. But I don't love the name of the things here. So we'll call it def target column. In place equals true. And H will probably set. I think we need to be much larger. Maybe something like 50 or 30. I'm not sure. So what we do is we have events. I'm going to call it Q some hits. I'm going to be some empty list. And then we'll say s plus equals zero. S minus equals zero. And then death will be G rock. So this is kind of supposed just can we pull up the documentation for this? Well, let me jump to function. I guess I don't have a. Well, here let me do this real quick because I want the documentation on that. So where were we? We are in labels. Whoops CD labels CD labels them indicators. If we'll go here. And I want to jump to the docs here. Okay, my LSP is apparently just not working. But is this just a shortcut for doing a role or a shift and then minus pandas dip. Periods first discrete difference of an element. So we have these. So should be one zero three one zero three. I guess it kind of makes sense now when you read the. I mean, obviously has is the case with everything mathematical. Once you know the answer makes perfect sense. But it kind of makes sense. It's saying the expected value at the previous time of the function. And so because of the serial correlation, you're basically saying that the expected price is just the previous price. But I kind of want to add in a fix me where we say. Add in a more sophisticated way of rejecting the expected value. Because one thing we should be able to do. At least for small enough time frames is we should be able to do something like instead of let's say we have discrete price measurements. Instead of saying that this is our kind of like E. I minus one her sorry E. T minus one why I. And this would be our kind of T. Instead of doing this for short enough time frames what we should be able to do is really get a better propagation. So maybe we have these prior time points right. Something like this. And if we want to predict the price at this time, it may be better to do some kind of like polynomial fit. So we could do like a spline fit. To project. We could also do a simple finite difference derivative. Take this if this is I minus one I minus two then we could simply do why I minus one why I minus two divided by delta T or whatever this bar kind of unit is if it's time or if it's volume it could be delta volumes or whatever it's going to be. This will give us some approximation for the why DT. And then we can simply do a Newton step and say what would we say we would say E based on I minus one of why T will be equal to why I minus one plus delta T times delta T. And then we can say that we could do this for short time frames delta Y over delta T evaluated at T. So this will be an interesting thing to implement. So I won't do it right now. So we can kind of do the pseudo code so we can say if T equals DY DT times DT plus plus Y of T minus one. And this should be kind of evaluated at T. So I'm going to write this as Y prime of T. And you can just note that Y prime of T will be a derivative. So but we'll take his approach for now. And we're saying the positive and negative are going to be the max of the prior positive and negative plus the dip at low i. We can also I'm going to do a fix me here because we can just in time compile this add JIT by converting series to numpy array. And so that will save us having to implement this in C plus plus because this is a very you can use num but to JIT this very easily and that will give you a big speed up her large data frames or scenarios where you want to run this on a lot of financial instruments. Okay, so we have this and we'll do this. I'm going to also add a sign because we don't I don't just want the time of the event but I also want whether it's s pass or s minus hitting. So let's do instead of Q some hist will say Q some sign equals an empty or as well. And so we will do Q some hist oh hits sorry not his. And we will do also Q some sign dot append one Q some sign dot append minus one. And then we can simply return our two new list Q some it's Q some sign. Let's try the book Q some on our data. We need to import it. Book Q some. We'll see. Q some bars close in place. We don't need any of these things anymore because his definition is very parameter free. G. Ross obviously not for it for us. So that will be for us. This will be equal to the F target column. Local variable s pass is s plus s minus. And then let's see if it will fix this for us. That's plus. And that should do it. So we get a bunch of different time stamps and a bunch of different signs as well. So let's plot. Let's see. Let's plot our closing price. plot that plot bars close. And then let's save these events. So we will say hits and signs equals book dot Q some. And then I believe what we can do is plot dot. So that's probably what we want to do maybe a scatter. And we will say hits. Close. I prefer this not being we're returning like date time indices. So we can do bars dot bar is what would be closed out lock hits. But I prefer index I low. So I prefer we return the indices. But let's do this. I guess s equals 10. And let's see how this looks. Yeah. Okay, looks a bit. Okay, well, it looks like crap. So let's see why let's maybe do a lot of X limb. Lotta scatter hits bars. I love. How do you trim this plot only five days at a time? Whatever. Yeah, that's not going to work. This is why I want to have indices. It's just a cleaner way of dealing with the data in my opinion. So we're only plotting the Q sum there. What is going on though? Oh, wait, why am I doing this? Wait, why is this looks so messy though? Maybe they're oh, well, what's our threshold threshold? It's probably way too low. H equals 30. Let's have HB, I don't know, 100. Or let's have it. We really shouldn't pass. This is so dependent on the stock price that we should have this as a required variable until I find a better way to estimate what it should be. H equals, I don't know, 200. H equals, whatever. Let's take a look at this. I'm going to fix this so that we return the indices. So in diff.index, let's do, range one, Lin diff. Then we can change this to be I look. Bring this down here. I don't know why it is insisting I do its tabbing. But this should be good. And this might work. Let's see. Red hits. Why are they still? Did I not save this? Oops. Why are we still getting timestamps? Oh, it doesn't like this. There we go. Now we have indices. So now plotting will be much easier. I'm just going to do list range. I'll just call it X is equal list range. Plot that plot. So then we can do plot that plot X is and bars close. Then we can do plot that scatter hits bar close dot i low hits. Did I type oh? Yes I did. Now it's going to be much easier for me to just slice out a part of the plot that I want to take a look at. Plot the X limb. Let's say 2,000 to 2500. And then let's say whoopsies. Plot that Y limb will be equal to. Can we do the panda's dot min or let's say bars close. But we want bars close. I look. Start. Stop. So I'm going to say start equals 2,000. Stop equals 2500. Start. Stop. Same thing here. Okay that gives us a much cleaner view of it. Can we bring these into the front? Bring this part of the plot into the front. Okay. Okay nice. So we have the Q some filter now working. Can we convert this to, can I make it do this with plot Lee? Convert this to plot Lee. So I can interactively scroll. Wow it is such a mess. How much code do you need to make a decent plot Lee plot? Let's see if it works. All right so now that we have the interactive plots so. And you see the sign on the use some filter kind of gives you a bit of indication as to whether you're hitting an s plus or an s minus at a given point. So what is this telling us? I'm also a bit confused on this. So let's read the explanation a bit more in depth. Represents are here. Let's get just like kind of a pure math explanation of it. Hello just saw you in the chat. Hope you're doing well. We're just building out this use some filter right now. So but I haven't really heard of it before so I want to read. Well I mean I've heard of it but I don't know the math that goes into its one or read a bit about it. It's quality control filter. Well this person just copy pastes the book that we're reading. Let's go back to the book. This procedure would recommend an action at the first t satisfying s t is greater than h for some threshold h. Note that s of t equals zero whenever the function itself is less than or equal to the expected value minus the previous value of this filter. Zero floor means we will skip some downward deviations that would otherwise make it negative. The reason is the filter set up to identify sequence of upside divergences from any reset level zero. Okay so when we think about this remember in his code this is really all this is is the previous f of t. So in other words we have where are we? F of t is less than f of t minus one minus s of t minus one. So let's think about let's kind of build out some numbers and see what this into context. So if we have like we start at zero so if these are our s's and this is f of t and then this is f of t minus one. And remember we're taking the max of the of where is it this. So it's all just right again up here max of zero comma the current function value why t. I think it makes more sense to write it this way f of t minus the previous one in his implementation there's some freedom for how you actually do this. Plus the previous s of t. Plus s of t minus one. So this is like delta f. And this is last s which we can just leave there so when the sum of the change in the function. Plus this previous values greater than. Some value. So we take the value. Well and then this is s of t and then whenever s of t itself is above some value I guess we take take it as a hit. So let's think about it like this. I think it kind of is starting to make sense for me. So we start at zero as a default f of t let's say is six prior price was four. So when we plug this in this becomes a two and this becomes a zero and this is larger. So the next s of t this one is going to be two. Then maybe the price keeps going up. You know f of t is so what let's say nine now last one was six. This next one will be again you take the previous s of t to plus this function difference which is three now. So we would be at five. And then so this keeps and maybe you go down and price down to six. This becomes a what would this be nine. We go down three. So this would become minus three. Plus s of t minus one. Wait is that what did I just say that right. So the difference at this point would be minus three plus the previous s value so this would be it to again. Okay so what this does is it builds out upward runs and that's why I guess we need it for both plus and minus. It builds out an upward run. So after some period of time you will have upward runs and the purpose of the max is zero here is so that's that you start with a price level that goes like this. If you didn't have the max zero here then in this region actually in this whole region probably s of t would be less than zero which you don't really want. So I'm going to go forward these net these kind of bounded from the bottom runs of price in either the upward or downward direction. And so it kind of makes sense now to me. We get some upward run of price we hit a green after we get some downward run of price we hit the negative sign and it's red. And so yeah this makes sense now. And you can see the threshold is what did we say it was what did I set it to I can accept this chat gpt thing now. What did we set it to we set it to 200. So what's the price here. It is 59.1k down here it's 58.9k so you can see that's roughly $200. So this roughly $200 run hits us to a green one. This run here was clearly not significant enough. I'm wondering why this hits though. How do I I don't use this can we go back to the full lot auto scale there we go. Let's look at a different region. So we go down some amount up up down down down down. I'm looking for one of these regions that didn't quite make sense to me. Something like this doesn't make sense to me this kind of makes me think I don't necessarily understand the filter too well. Ah I do understand so okay this makes much more sense. So when you have the so you you're basically resetting at this point right because you hit a red. And then you did all this upward price movement but because when you do the this would be for an s negative right. When you do the s negative the upward price movement doesn't hit because you're taking the min. For the so this is really like sd for plus but for the s t negative. This would be equal to min of zero and this kind of same same logic here. And in the case where you you just hit but you make these big price movements up. This min here is going to be hitting your zero instead of the upward price movement which is going to be some positive number. So that's why you can get these somewhat lateral movements. Okay so we have the function properly implemented and in the future I think having better price propagation for this guess sort of expected value if the price is going to be an interesting thing to add. Took a little bit longer today to do that and let's quickly look into what we're going to do then tomorrow. So didn't actually get as much done today as I was hoping but I wasn't able to get on until a bit later. And if anyone else has anything you want to sort of talk about or you have any questions just drop them in the chat and we can also go over that. Now the thing that I will look at is how we are going to handle this historical API. So in the cracked package which has been going pretty well. Can I open the correct thing? Where are we? Should be here I think actually. Let's say Kraken historical API V2. So the goal will be basically I have a we haven't worked on it in a few days so I'll talk about it and I'll show it I guess there are a few people here maybe new people who haven't seen the web app. So I'll go back here. Back, back, cracked. Cracked web app. Now the bulk of the code is not the web app but the web app is a bit of it so I'll do this. Let's start a team accession team ox. Open a couple of terminals here and I will do Python L2 feed. Well first let me clear the data. Remove data slash star dot I'll just remove everything I guess. And we'll do Python L2 feed and I promise this will make sense in a second what I'm doing Python OHLC examples. So this cracked package is a way of getting live data feeds from a crypto exchange. This one in this case it's Kraken but I'll be adding more in the future. And so we also have a web app that I will show you. Let me copy this. Oh shoot I forgot. If I do control C it's going to cancel B server. Come over here. And this web app basically for us live updates with the data that we are talking about here. So paste this in. And you get this kind of live updating L2 data. This is the market by price. It's called L2 MVP. These are order book. However people call this all different things basically it shows you the top and price levels on the buying sell side. And then it shows you also the volume at those levels. The other thing is it shows you the stock price and the spread. And the stock price here is just the best bid offer. Still a little bit to rough around the edges as you can see there glitched out a little bit. But we haven't had any price movement in this best bid. It's been sitting at 354.6 this whole time. And you can see if you zoom in maybe can I zoom in? That this is at 3546. And you can also see the spread here. So the spread between the bid best bid and best ask is point one. And so that's also being tracked down here. And the other thing is this sample is not at fixed times but at fixed trade volume. And then we also have the handle sticks. So in this case these are just the one minute candles. But something that I want to do right is you want to be able to spin up this web app and have. You know some good historical data ready to go even if you haven't been listening to the feed for an hour you maybe want the last hours worth of candlesticks the last hours worth worth of a best bid offer. And you you wouldn't want the last hours L2 data but these other ones you might. And so what we're going to do tomorrow is. Where are we spot futures I also want to look at the futures API. Although I might not be able to do it because you can't trade futures on cracking if you're from the US. And I'm in the US. Let's see if they have historical data anywhere. Funding sub accounts NFT. Earn. Who's whose algo trading NFTs. That's crazy. Market data. Returns up to 720. Of the most recent regardless of. The synths keyword so let's look at the. Responses. Okay yeah so what we'll be doing is implementing this tomorrow. Where we can pull the historical data though this is not enough historical data so I want to see if they have any. More. Crack in historical data API. What's up angel. We're just working on getting this crack in the interface up and running so it's pretty much going now but. I want to add some some things to be able to pull historical data. The idea is to combine this cracked package with the dolphin package so you can get all sorts of financial data and then do your machine learning on it and sort of a. One stop fashion. So here we have where are we. Historical data you can access CSVs of the historical data are you serious. Oh for executions orders mark price since the 28th of May 21 please use the public rest API. Okay nice so they do have some API for historical data. Now how we get it I don't know can we use their web socket for historical data. That would be nice. Ticker feed contains nope we want historical so it looks like we have to use the rest API. Where were we when the market history here we go and this is within the HTTP API. Get public execution events. I can't code I've been using chatchy PT to help me I'm trying to learn by myself but it's a slow ground yet so I don't know if you've used cursor but I can show you cursor it's kind of a nice if you're new. It's debatable how. Good relying on it too much would be when you are new but. It's useful especially for when you have some code that works right in cursor which is basically cursor is a fork of VS code. Right within the code you can do something like let me find something that might be a bit infusing. Yeah so like here we have a function that computes correlations at different times and compares them to correlations over the whole data set. So we could do something like control K or let's say control L and say explain this function to me and you can do it right within the cursor interface. I'm using the chatchip.co1 so it's a little bit slower because it has this thinking phase but I'll check back in a second oh no it already cooked up a response and so basically it explains this stuff for you. So you can ask questions about code that you already have working but you can also do stuff like you know if I want to make let's scroll down here. Where are we? Something like one of these ones. If I don't know how to change the color of the line for example it's kind of a too simple of an example but we could just control highlight or highlight and then you hit control K within cursor and you can say you know change the line color to purple and make the plot look nice and modern for example let's see what it does there. And you can select the model that you have it use makes all these changes directly in the code so it's so much nicer than having to just copy paste code from GPT into your thing and you know it didn't really do too much nice here but it did change the line color and I mean arguably you could say it looks more modern it's kind of a not the best prompt on my end but this. Editor I've been really liking and there's definitely a two week free trial I think after that it's 20 bucks a month or something so it's not the cheapest but a little bit more expensive than co pilot so if you have the other thing is I don't know if you're a student but if you're a student you can get GitHub pro for free and GitHub pro comes with GitHub co pilot. So that's another useful thing you might be able to do if you're trying to use AI to accelerate your you know learning of how to code. That's kind of but don't rely on it too much so if you are new use it when you're really stuck but don't underestimate the value of sitting there and kind of really trying to bang your head on a problem sometimes. Because you will learn fast by making stakes being frustrated and kind of annoying but if you're in it for the long run it's a good thing to do. So like for me when I'm implementing numerical code or I'm working on something that I know I really want to have a solid understanding of I won't try to you know try to use the AI minimally but when I'm doing something like building a web app or. Looking for nice plots I don't really care about having a great understanding of how all that front end stuff works so I'll just use the AI for that all day. But that's just me. And yeah so I was looking at this I want to see oh yeah I want to see what they have what they give you access to. So market history lists trades for a market authentication is not required so something like this is another good example where I don't really care too much about how this works so what I'm going to do is I'm going to ask it to just build this for me. And let's see what it can do while we're on the topic of cursor so let's build the let's bring up the chat. Here is the sample what's it called get request. Get request from the crack in historical API can you please write me a small script in this notebook to query it and return some data for Bitcoin slash USD. So let's see how it does. Betch crack in Bitcoin USD and then when you do the query also with cursor one nice thing is you can just hit apply so I'll click right here and hit apply and it should. Oh right no you can't do a Jupyter notebooks for the apply thing but if this was a basic Python script then you would be able to easily do that so let's see what happens no executions data found in the response okay. So let's see what it did that just execution data for Bitcoin USD so it's for tradable PI XBT USD. Can we get a list of their tradeables crack analyst tradeables. So let's even see if this is a valid a valid sort of query. Oh no no this is a well yeah but okay I don't want to futures let's see don't query for futures just simple spot trading. US for some reason is not allowed to trade futures on cracking which is also why I want to add a Fed Max or by Nancy or something else. Let's give this a shot. And type has no okay so it's not that good at using just this to do it. Let's see where it's querying so let's read through actually the function and try and see what it came up with. Betcher Crackensbot Bitcoin USD. What if I do this? So we go to this URL the public trades URL or that's our URL we end up querying at the API endpoint we look for the pair which is specified here. Since pagination zero fetches the most recent trades try response equals requests dot get URL per am equals per am source per am is that correct parameters. So here's an example response. Where is it list trades for market tradable where are we getting the list of tradables though. Oh we're in the futures API no wonder futures API I don't even think we're allowed to query from the US. Do they not have historical spot trading data crack in historical spot trading data. No I guess not. I guess they don't have it so we will be relegated to getting the historical data here. Oh why do I keep putting me in the futures crack in V2 API. If I can't find it here I'll just look more upstream so that I mean this is going to be a good for me just clicking around looking for this. So I'll do this on my own time if I can't find it immediately or pretty quickly. But APIs let's see what's in the rest API can we get recent trade to go. So you can get the most 1000 recent trades how many candlesticks can you get 720 recent candlesticks that's plenty so that's plenty for the purposes of the web app I'll be able to populate the candlesticks pretty quickly there. Alright so what's this what can we click this. Now let's say a BTC slash USD. Oh cool. So we can just do this over the rest API and we can well we'll do it from Python. Let's try this out. That's nice they give you the code right away. Let's give it a shot. Much nicer than having to do anything like this. Wow nice that's very easy. So this will be super quick to add tomorrow and integrate into the web app. Alright so a bit of a quicker stream today. Thank you all for joining but I'm going to be heading off. Got to eat I will be back tomorrow. One thing though for those of you who just joined I don't know if the chat shows the whole time but let me send you the discord link if you want to join. Feel free to join we have a bunch of people who are some people who've been trading for a while. Coding for a while and a bunch of people who are new to it as well just wanting to learn. So not a super busy server but a lot of people who are interested in this stuff. So if you're interested feel free to join I'll say thank you for watching today and I hope you all have a good rest of your day.